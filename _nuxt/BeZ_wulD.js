import{v as O,bD as x,cV as W,K as S,aP as V,y as A,f as B,cW as D,cX as N,bM as $,cY as J,aQ as T,cZ as F,c_ as H,c$ as I,z as K,L as P}from"./DZyWbfTA.js";function Y(e={}){const{inheritAttrs:t=!0}=e,s=x(),d=B({setup(r,{slots:i}){return()=>{s.value=i.default}}}),a=B({inheritAttrs:t,props:e.props,setup(r,{attrs:i,slots:o}){return()=>{var u;s.value;const c=(u=s.value)==null?void 0:u.call(s,{...e.props==null?U(i):r,$slots:o});return t&&c?.length===1?c[0]:c}}});return D({define:d,reuse:a},[d,a])}function U(e){const t={};for(const s in e)t[H(s)]=e[s];return t}const E=N?window:void 0;function b(e){var t;const s=$(e);return(t=s?.$el)!=null?t:s}function y(){const e=x(!1),t=V();return t&&K(()=>{e.value=!0},t),e}function G(e){const t=y();return O(()=>(t.value,!!e()))}function L(e){return JSON.parse(JSON.stringify(e))}function Q(e,t,s={}){const{window:d=E,...a}=s;let r;const i=G(()=>d&&"ResizeObserver"in d),o=()=>{r&&(r.disconnect(),r=void 0)},u=O(()=>{const n=$(e);return Array.isArray(n)?n.map(f=>b(f)):[b(n)]}),c=S(u,n=>{if(o(),i.value&&d){r=new ResizeObserver(t);for(const f of n)f&&r.observe(f,a)}},{immediate:!0,flush:"post"}),v=()=>{o(),c()};return J(v),{isSupported:i,stop:v}}function Z(e,t={width:0,height:0},s={}){const{window:d=E,box:a="content-box"}=s,r=O(()=>{var n,f;return(f=(n=b(e))==null?void 0:n.namespaceURI)==null?void 0:f.includes("svg")}),i=x(t.width),o=x(t.height),{stop:u}=Q(e,([n])=>{const f=a==="border-box"?n.borderBoxSize:a==="content-box"?n.contentBoxSize:n.devicePixelContentBoxSize;if(d&&r.value){const l=b(e);if(l){const h=l.getBoundingClientRect();i.value=h.width,o.value=h.height}}else if(f){const l=I(f);i.value=l.reduce((h,{inlineSize:m})=>h+m,0),o.value=l.reduce((h,{blockSize:m})=>h+m,0)}else i.value=n.contentRect.width,o.value=n.contentRect.height},s);W(()=>{const n=b(e);n&&(i.value="offsetWidth"in n?n.offsetWidth:t.width,o.value="offsetHeight"in n?n.offsetHeight:t.height)});const c=S(()=>b(e),n=>{i.value=n?t.width:0,o.value=n?t.height:0});function v(){u(),c()}return{width:i,height:o,stop:v}}const w=new Map;function j(e){const t=T();function s(o){var u;const c=w.get(e)||new Set;c.add(o),w.set(e,c);const v=()=>a(o);return(u=t?.cleanups)==null||u.push(v),v}function d(o){function u(...c){a(u),o(...c)}return s(u)}function a(o){const u=w.get(e);u&&(u.delete(o),u.size||r())}function r(){w.delete(e)}function i(o,u){var c;(c=w.get(e))==null||c.forEach(v=>v(o,u))}return{on:s,once:d,off:a,emit:i,reset:r}}function q(e,t,s,d={}){var a,r,i;const{clone:o=!1,passive:u=!1,eventName:c,deep:v=!1,defaultValue:n,shouldEmit:f}=d,l=V(),h=s||l?.emit||((a=l?.$emit)==null?void 0:a.bind(l))||((i=(r=l?.proxy)==null?void 0:r.$emit)==null?void 0:i.bind(l?.proxy));let m=c;m=m||`update:${t.toString()}`;const C=p=>o?typeof o=="function"?o(p):L(p):p,M=()=>F(e[t])?C(e[t]):n,z=p=>{f?f(p)&&h(m,p):h(m,p)};if(u){const p=M(),R=A(p);let g=!1;return S(()=>e[t],_=>{g||(g=!0,R.value=C(_),P(()=>g=!1))}),S(R,_=>{!g&&(_!==e[t]||v)&&z(_)},{deep:v}),R}else return O({get(){return M()},set(p){z(p)}})}export{j as a,Z as b,Y as c,q as u};
